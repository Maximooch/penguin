<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Penguin Design Experiments</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(180deg, #2c3e50 0%, #3498db 100%);
            font-family: 'Arial', sans-serif;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            max-width: 300px;
        }
        #info h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        #info p {
            margin: 5px 0;
            font-size: 13px;
            line-height: 1.5;
        }
        .penguin-label {
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>üêß Penguin Design Lab</h1>
        <p><span class="penguin-label">Left:</span> Chubby Emperor Style</p>
        <p><span class="penguin-label">Center:</span> Classic Waddle Stance</p>
        <p><span class="penguin-label">Right:</span> Baby Penguin</p>
        <p style="margin-top: 15px;">üñ±Ô∏è Drag to rotate ‚Ä¢ üîç Scroll to zoom</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 15, 50);
        camera.lookAt(0, 8, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
        sunLight.position.set(20, 30, 20);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0xadd8e6, 0.3);
        fillLight.position.set(-20, 10, -10);
        scene.add(fillLight);

        // Colors
        const BLACK = 0x1a1a1a;
        const WHITE = 0xffffff;
        const ORANGE = 0xff8c42;
        const YELLOW = 0xffd700;
        const DARK_GRAY = 0x4a4a4a;

        // Voxel helper
        function createVoxel(x, y, z, color) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            cube.castShadow = true;
            cube.receiveShadow = true;

            // Subtle edge lines
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(
                edges, 
                new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.15, transparent: true })
            );
            cube.add(line);

            return cube;
        }

        // DESIGN 1: Chubby Emperor Penguin (round, rotund)
        function buildChubbPenguin() {
            const penguin = new THREE.Group();

            // Very round body - wider at middle
            // Bottom layer (feet level)
            for (let x = -2; x <= 2; x++) {
                for (let z = -2; z <= 2; z++) {
                    if (Math.abs(x) + Math.abs(z) <= 3) {
                        penguin.add(createVoxel(x, 0, z, BLACK));
                    }
                }
            }

            // Expanding body (y: 1-3) - getting wider
            for (let y = 1; y <= 3; y++) {
                const width = 3;
                for (let x = -width; x <= width; x++) {
                    for (let z = -width; z <= width; z++) {
                        const dist = Math.abs(x) + Math.abs(z);
                        if (dist <= 4) {
                            // White belly in front (wider)
                            if (z >= -1 && Math.abs(x) <= 2) {
                                penguin.add(createVoxel(x, y, z, WHITE));
                            } else {
                                penguin.add(createVoxel(x, y, z, BLACK));
                            }
                        }
                    }
                }
            }

            // Middle body (y: 4-6) - widest part
            for (let y = 4; y <= 6; y++) {
                const width = 3;
                for (let x = -width; x <= width; x++) {
                    for (let z = -width; z <= width; z++) {
                        const dist = Math.abs(x) + Math.abs(z);
                        if (dist <= 4) {
                            if (z >= -1 && Math.abs(x) <= 2) {
                                penguin.add(createVoxel(x, y, z, WHITE));
                            } else {
                                penguin.add(createVoxel(x, y, z, BLACK));
                            }
                        }
                    }
                }
            }

            // Upper body (y: 7-8) - narrowing
            for (let y = 7; y <= 8; y++) {
                for (let x = -2; x <= 2; x++) {
                    for (let z = -2; z <= 2; z++) {
                        if (Math.abs(x) + Math.abs(z) <= 3) {
                            if (z >= 0 && Math.abs(x) <= 1) {
                                penguin.add(createVoxel(x, y, z, WHITE));
                            } else {
                                penguin.add(createVoxel(x, y, z, BLACK));
                            }
                        }
                    }
                }
            }

            // Neck (y: 9)
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    if (Math.abs(x) + Math.abs(z) <= 2) {
                        penguin.add(createVoxel(x, 9, z, z >= 0 ? WHITE : BLACK));
                    }
                }
            }

            // Head (y: 10-12) - rounder
            for (let y = 10; y <= 12; y++) {
                const size = y === 12 ? 1 : 1.5;
                for (let x = -1; x <= 1; x++) {
                    for (let z = -1; z <= 1; z++) {
                        if (y === 12 && (Math.abs(x) > 0 || Math.abs(z) > 1)) continue;
                        penguin.add(createVoxel(x, y, z, BLACK));
                    }
                }
            }

            // Face markings - yellow/white patches
            penguin.add(createVoxel(-1, 11, 1, YELLOW));
            penguin.add(createVoxel(1, 11, 1, YELLOW));
            penguin.add(createVoxel(-1, 10, 1, WHITE));
            penguin.add(createVoxel(1, 10, 1, WHITE));

            // Eyes
            penguin.add(createVoxel(-1, 11, 2, BLACK));
            penguin.add(createVoxel(1, 11, 2, BLACK));

            // Beak - pointy
            penguin.add(createVoxel(0, 10, 2, ORANGE));
            penguin.add(createVoxel(0, 11, 2, ORANGE));
            penguin.add(createVoxel(0, 10, 3, ORANGE));

            // Stubby flippers sticking out
            for (let y = 4; y <= 7; y++) {
                penguin.add(createVoxel(-4, y, 0, BLACK));
                penguin.add(createVoxel(-4, y, -1, BLACK));
                penguin.add(createVoxel(4, y, 0, BLACK));
                penguin.add(createVoxel(4, y, -1, BLACK));
            }

            // Wide-set feet (waddle stance)
            penguin.add(createVoxel(-2, -1, 3, ORANGE));
            penguin.add(createVoxel(-2, -1, 4, ORANGE));
            penguin.add(createVoxel(-3, -1, 3, ORANGE));

            penguin.add(createVoxel(2, -1, 3, ORANGE));
            penguin.add(createVoxel(2, -1, 4, ORANGE));
            penguin.add(createVoxel(3, -1, 3, ORANGE));

            return penguin;
        }

        // DESIGN 2: Classic Standing Penguin (proportional)
        function buildClassicPenguin() {
            const penguin = new THREE.Group();

            // Compact oval body
            // Base (y: 0-1)
            for (let y = 0; y <= 1; y++) {
                for (let x = -1; x <= 1; x++) {
                    for (let z = -2; z <= 1; z++) {
                        if (Math.abs(x) + Math.abs(z) <= 2) {
                            penguin.add(createVoxel(x, y, z, BLACK));
                        }
                    }
                }
            }

            // Main body (y: 2-7) - sleek oval
            for (let y = 2; y <= 7; y++) {
                for (let x = -2; x <= 2; x++) {
                    for (let z = -2; z <= 2; z++) {
                        const dist = Math.sqrt(x*x/1.5 + z*z/2);
                        if (dist <= 2) {
                            // White belly - narrower
                            if (z >= 0 && Math.abs(x) <= 1) {
                                penguin.add(createVoxel(x, y, z, WHITE));
                            } else {
                                penguin.add(createVoxel(x, y, z, BLACK));
                            }
                        }
                    }
                }
            }

            // Shoulders/neck (y: 8)
            penguin.add(createVoxel(-1, 8, 0, BLACK));
            penguin.add(createVoxel(0, 8, 0, BLACK));
            penguin.add(createVoxel(1, 8, 0, BLACK));
            penguin.add(createVoxel(0, 8, 1, WHITE));

            // Head (y: 9-11) - proportional
            for (let y = 9; y <= 11; y++) {
                for (let x = -1; x <= 1; x++) {
                    for (let z = -1; z <= 1; z++) {
                        if (y === 11 && Math.abs(x) + Math.abs(z) > 1) continue;
                        penguin.add(createVoxel(x, y, z, BLACK));
                    }
                }
            }

            // White face patches
            penguin.add(createVoxel(-1, 9, 1, WHITE));
            penguin.add(createVoxel(1, 9, 1, WHITE));
            penguin.add(createVoxel(-1, 10, 1, WHITE));
            penguin.add(createVoxel(1, 10, 1, WHITE));

            // Eyes
            penguin.add(createVoxel(-1, 10, 2, BLACK));
            penguin.add(createVoxel(1, 10, 2, BLACK));

            // Beak
            penguin.add(createVoxel(0, 9, 2, ORANGE));
            penguin.add(createVoxel(0, 10, 2, ORANGE));
            penguin.add(createVoxel(0, 9, 3, YELLOW));

            // Flippers - angled down naturally
            penguin.add(createVoxel(-3, 6, 0, BLACK));
            penguin.add(createVoxel(-3, 5, 0, BLACK));
            penguin.add(createVoxel(-3, 4, 1, BLACK));

            penguin.add(createVoxel(3, 6, 0, BLACK));
            penguin.add(createVoxel(3, 5, 0, BLACK));
            penguin.add(createVoxel(3, 4, 1, BLACK));

            // Feet - close together (standing)
            penguin.add(createVoxel(-1, -1, 2, ORANGE));
            penguin.add(createVoxel(-1, -1, 3, ORANGE));
            penguin.add(createVoxel(0, -1, 2, ORANGE));

            penguin.add(createVoxel(1, -1, 2, ORANGE));
            penguin.add(createVoxel(1, -1, 3, ORANGE));

            return penguin;
        }

        // DESIGN 3: Baby Penguin (cute, small, fluffy proportions)
        function buildBabyPenguin() {
            const penguin = new THREE.Group();

            // Fluffy round body - very compact
            // Base
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    penguin.add(createVoxel(x, 0, z, DARK_GRAY));
                }
            }

            // Round fluffy body (y: 1-4)
            for (let y = 1; y <= 4; y++) {
                for (let x = -2; x <= 2; x++) {
                    for (let z = -2; z <= 2; z++) {
                        if (Math.abs(x) + Math.abs(z) <= 3) {
                            // Baby penguins are mostly gray/brown
                            if (z >= 0 && Math.abs(x) <= 1 && y >= 2) {
                                penguin.add(createVoxel(x, y, z, WHITE));
                            } else {
                                penguin.add(createVoxel(x, y, z, DARK_GRAY));
                            }
                        }
                    }
                }
            }

            // Transition to head (y: 5)
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    penguin.add(createVoxel(x, 5, z, DARK_GRAY));
                }
            }

            // Big head (y: 6-8) - baby proportions
            for (let y = 6; y <= 8; y++) {
                for (let x = -2; x <= 2; x++) {
                    for (let z = -2; z <= 2; z++) {
                        if (Math.abs(x) + Math.abs(z) <= 3) {
                            penguin.add(createVoxel(x, y, z, DARK_GRAY));
                        }
                    }
                }
            }

            // Fluffy tuft on top
            penguin.add(createVoxel(0, 9, 0, DARK_GRAY));
            penguin.add(createVoxel(-1, 9, 0, DARK_GRAY));
            penguin.add(createVoxel(1, 9, 0, DARK_GRAY));

            // Big eyes (baby style)
            penguin.add(createVoxel(-1, 7, 2, WHITE));
            penguin.add(createVoxel(1, 7, 2, WHITE));
            penguin.add(createVoxel(-1, 7, 3, BLACK));
            penguin.add(createVoxel(1, 7, 3, BLACK));

            // Small beak
            penguin.add(createVoxel(0, 6, 2, ORANGE));
            penguin.add(createVoxel(0, 7, 2, ORANGE));

            // Tiny stubby flippers
            penguin.add(createVoxel(-3, 3, 0, DARK_GRAY));
            penguin.add(createVoxel(-3, 2, 0, DARK_GRAY));
            penguin.add(createVoxel(3, 3, 0, DARK_GRAY));
            penguin.add(createVoxel(3, 2, 0, DARK_GRAY));

            // Small feet
            penguin.add(createVoxel(-1, -1, 1, ORANGE));
            penguin.add(createVoxel(-1, -1, 2, ORANGE));
            penguin.add(createVoxel(1, -1, 1, ORANGE));
            penguin.add(createVoxel(1, -1, 2, ORANGE));

            return penguin;
        }

        // Create all three penguins
        const chubbPenguin = buildChubbPenguin();
        chubbPenguin.position.set(-20, 0, 0);
        scene.add(chubbPenguin);

        const classicPenguin = buildClassicPenguin();
        classicPenguin.position.set(0, 0, 0);
        scene.add(classicPenguin);

        const babyPenguin = buildBabyPenguin();
        babyPenguin.position.set(20, 0, 0);
        scene.add(babyPenguin);

        // Ground platform for each
        function createPlatform(x) {
            const platform = new THREE.Group();
            for (let px = -4; px <= 4; px++) {
                for (let pz = -4; pz <= 4; pz++) {
                    if (Math.abs(px) + Math.abs(pz) <= 6) {
                        platform.add(createVoxel(x + px, -2, pz, 0xe3f2fd));
                    }
                }
            }
            return platform;
        }

        scene.add(createPlatform(-20));
        scene.add(createPlatform(0));
        scene.add(createPlatform(20));

        // Ground
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -3;
        ground.receiveShadow = true;
        scene.add(ground);

        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                camera.position.x += deltaX * 0.05;
                camera.position.y -= deltaY * 0.05;
                camera.position.y = Math.max(5, Math.min(30, camera.position.y));

                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.05;
            camera.position.z = Math.max(30, Math.min(80, camera.position.z));
        });

        // Animation
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Animate each penguin differently
            chubbPenguin.position.y = Math.sin(time * 1.5) * 0.3;
            chubbPenguin.rotation.y = Math.sin(time * 0.8) * 0.15;

            classicPenguin.position.y = Math.sin(time * 2) * 0.2;
            classicPenguin.rotation.y = Math.sin(time) * 0.1;

            babyPenguin.position.y = Math.sin(time * 2.5) * 0.4;
            babyPenguin.rotation.y = Math.sin(time * 1.2) * 0.2;
            babyPenguin.rotation.z = Math.sin(time * 1.5) * 0.05;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>